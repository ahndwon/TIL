# Ch27_Broadcast_Intent
## 일반 인텐트 vs 브로드캐스트 인텐트
시스템의 많은 컴포넌트들이 어떤 이벤트가 생겼는지 알 필요가 있을 때 안드로이드는 브로드캐스트 인텐트를 사용해서 그것에 관해 모든 컴포넌트에 알려준다.
인텐트와 브로드캐스트의 차이점은 브로드 캐스트 인텐트는 **수신자로 등록한 여러 컴포넌트가 동시에** 받을 수 있다는 점이다.

일반 인텐트는 특정 액티비티와 서비스만 응답 가능하다.
브로드캐스트 인텐트는 브래드캐스트 수신자로 등록한 여러 액티비티나 서비스가 동시에 받고 응답할 수 있다.

## 장치 부팅 시 앱 깨우기
시스템에서는 장치의 전원이 켜질 때마다 BOOT_COMPLETED 액션을 갖는 브로드캐스트 인텐트를 전송한다. 따라서 그러한 브래드캐스트 인텐트를 리스닝하는 브로드캐스트 수신자를 생성하고 등록하면 장치 부팅이 된 것을 감지 할 수 있다.

### 브로드캐스트 수신자를 생성하고 등록하기
브로드캐스트 수신자는 두 가지 형태, 즉 독자적 수신자(standalone receiver)와 동적 수신자(dynamic receiver)로 구분할 수 있다.

두 가지 모두 브로드캐스트 인텐트를 리스닝하는 기능은 동일하다. 
단, 독자적 수신자는 매니페스트에 등록하며 프로세스가 종료되더라도 시작될 수 있다.
동적 수신자는 매니페스트가 아닌 코드에서 등록하므로 우리 앱의 특정 액티비티나 프래그먼트가 실행될 때만 동작하게 할 수 있다.


서비스나 액티비티처럼 브로드캐스트 수신자는 시스템에 등록되어야 동작한다.


### 브로드캐스트 수신자 사용하기
브로드캐스트 수신자는 짧은 시간 동안만 살아있으므로 그것을 사용해서 할 수 있는 일에는 제약이 따른다 .일체의 비동기 API를 사용할 수 없다.
 `onReceive(Context, Intent)`메서드가 씰행되는 동안만 수신자가 살아있다.
`onReceive(Context, Intent)`는 main 스레드에서 실행되므로 이 메서드 내부에서 시간이 많이 걸리는 일을 할 수 없다.


## 포그라운드 통지의 필터링
문제 - 사용자가 이미 앱을 화면에서 보고 있는 상태인데도 통지가 전달됨
-> 브로드캐스트 인텐트로 해결

**해결법**
1. 우리의 커스텀 브로드캐스트 인텐트를 보내고 받는다, 이때 우리 앱의 컴포넌트에서만 받을 수 있게 제한한다.
2. 우리의 브로드캐스트 수신자를 매니페스트가 아닌 코드에서 동적으로 등록한다
3. 끝으로 여러 수신자에게 차례대로 데이터를 전달하기 위해 순차(ordered) 브로드캐스트를 전송한다.

### 브로드캐스트 인텐트 전송
```kotlin
sendBroadcast(Intent(ACTION_SHOW_NOTIFICATION))
```

### 동적 수신자를 생성하고 등록하기
PhotoGallerFragment가 살아있는 동안에만 인텐트를 수신하게 해야되
-> 동적 브로드캐스트 수신자 사용


### private 퍼미션 사용하기
브로드캐스트 인텐트를 우리 앱에서만 수신할 수 있게 하기 원하면 두가지 방법이 있다.
1. AndroidManifest에서 `android:exported="false"`속성을 수신자에 추가해주면 된다.
2. 퍼미션 생성을 한다.
```xml
<permission android:name="online.ahndwon.photogallery.PRIVATE"
            android:protectionLevel="signature" />

<uses-permission android:name="online.ahndwon.photogallery.PRIVATE" />
```



### 보호 수준
모든 커스텀 퍼미션에서는 `android:protectionLevel`의 값을 지정해야 한다. 보호 수준을 나타내는 protectionLevel 속성은 퍼미션의 사용법을 안드로이드에 알려준다.

Signature protectionLevel - 다른 애플리케이션이 우리 퍼미션을 사용하고자 한다면 우리 애플리케이션과 동일한 인증 키로 서명해야 함


### 순차 브로드캐스트 인텐트로 결과 받기
일반 브로드캐스트 인텐트는 모든 수신자가 동시에 수신한다. 
실제로는 onReceive() 가 main스레드에서 호출되므로 수신자들이 동시에 실행되지는 않는다. 
그러나 그것들이 어떤 특정 순서로 실행되게 하는 것은 불가능하다. 
또한 실행이 끝난 시점도 알수 없다.

-> 브로드캐스트 수신자들 상호간의 소통은 쉽지 않고, 인텐트 전송자가 수신자들로부터 어떤 정보를 받는 것도 어렵다.

**결과 수신자(result receiver)**
순차 브로드캐스트 인텐트를 사용하면 양방향 소통을 구현할 수 있다. 순차 브로드캐스트는 브로드캐스트 수신자들이 브로드캐스트 인텐트를 순서적으로 처리할 수 있게 해준다.
브로드캐스트 전송자가 특별한 브로드캐스트 수신자를 전달함으로써 브로드캐스트 수신자들로부터 결과를 받을 수 있게 해준다.


## 수신자와 오래 실행되는 태스크
Main 루프의 실행 시간 제약보다 더 오랫동안 실행되는 태스크로 브로드캐스트 인텐트를 시작시키고 싶을 경우
1. 그런 일을 하는 코드를 브로드캐스트 인텐트 대신 서비스에 넣은 다음, 브로드캐스트 수신자에서 그 서비스를 시작 시키는 것
2. `BroadcastReceiver.goAsync()`메서드 사용. 이 메서드는 나중에 겨로가를 제공하는 데 사용될 수 있는 BroadcastReceiver.PendingResult 객체를 반환한다. 따라서 그 PendingResult 객체를 AsyncTask 에 전달하여 더 오래 실행되는 일을 수행할 수 있다. -> 단 단점은 유연성이 떨어진다. 여전히 5초 이내에 브로드캐스트 인텐트를 처리해야 한다.

## 로컬 이벤트
브로드캐스트 인텐트는 전역적인 형태로 시스템 전체에 걸쳐 정보를 전파할 수 있다. 그런데 우리 앱의 프로세스 내부에선 발생 이벤트를 전파하고 싶다면 **이벤트 버스**를 사용하는 것이 좋다.

이벤트 버스는 공유 버스나 데이터 스트림의 개념으로 동작하며, 우리 애플리케이션의 컴포넌트가 구독할 수 있다.

### 서드파티 이벤트 버스 라이브러리
* greenrobot의 EventBus
* Square - Otto
* RxJava - Subjects, Observables



#android/실무에바로적용하는안드로이드