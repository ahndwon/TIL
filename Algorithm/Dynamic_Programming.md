# Dynamic_Programming
특정 범위까지의 값을 구하기 위해서 그것과 다른 범위까지의 값을 이용하여 효율적으로 값을 구하는 알고리즘 설계 기법

* 간단하게 설명하면  **답을 재활용**하는 거다.
* 엄밀히 말해 동적 계획법은 구체적인 알고리즘이라기보다는 문제해결 패러다임에 가까움
* 답을 구하기 위해 했던 계산을 반복하는 류의 문제의 구조인 **Optimal Substructure** 에서 동적 계획법이 효과를 발휘

**요약**
주로( 재귀 + 캐싱 )

## 구현
* f(a, b) = f(a-1, b) + f(a, b-1) (a, b >= 1)
* f(0, 0) = 1, 임의의 자연수 n에 대해 f(n, 0) = f(0, n) = 1

![](Dynamic_Programming/61C4749D-4484-4FB0-82F8-F61AA96EB269.png)

f(2,2)를 구하기 위해선 총 5번의 연산을 거쳐야 하지만
중복되는 계산인 f(1, 1)을 재활용한다면 1회 줄어들어 4번의 연산만 하면 된다.
계산이 늘어날수록 동적계회법을 이용하면 효과가 크다.

![](Dynamic_Programming/5B9C8067-331E-4D9F-8698-4276381E78B8.png)



## 예시
**피보나치 수열**
함수가 호출되면 프로그램 메모리의 스택(Stack)이라는 곳에 데이터가 쌓이게 된다. 그 함수의 실행이 끝났을 때 다시 메모리가 해제되는 방식인데, 이 말인 즉슨 함수가 계속 호출되면 메모리에 쌓이는 것들이 계속 증가한다. -> 숫자가 커지면 시간 복잡도와 공가 복잡도가 지수 스케일로 폭발(Exponential Explosion)

### 동적계획법 형태의 피보나치

**Top-down**
 위에서 내려오는 것, 즉, 큰 문제부터 시작해서 계속 작은 문제로 분할해 가면서 푸는 것

```c
int memo[100]; //메모이제이션 공간. 전역 변수이므로 0으로 초기화
int fibonacci(int n)
{
  if (n<=1) //0번째, 1번째 피보나치 수
    return n;
  if (memo[n]!=0) //메모가 있는지 확인(0으로 초기화되었으므로 0이 아니라면 메모가 쓰인 것임)
    return memo[n]; //메모 리턴
  memo[n]=fibonacci(n-1) + fibonacci(n-2); //작은 문제로 분할
  return memo[n];
}
```


**Bottom-up**
바닥에서 올라오는 것, 즉, 작은 문제부터 시작해서 작은 문제를 점점 쌓아 큰 문제를 푸는 것
```c
int f_data[N] = {1, 1}; // N은 정의하기 나름
int last_pos = 1; // 마지막으로 계산한 지점. 이 코드에선 이미 f_data[1]까지 정의되어있기 때문에 1로 초기화한다.
int f(int n) //피보나치 수열의 제 n항을 구한다. 배열의 관점에서는 n-1번째 요소를 구하는 것.
{
    int i;
    if(f_data[n-1] == 0)  // 아직 구한 적이 없으면 구한다
    {
        for(i=last_pos+1; i<n; ++i)
        {
            f_data[i] = f_data[i-1] + f_data[i-2];
        }
        last_pos = n-1;
    }
    return f_data[n-1];
}
```


#공통