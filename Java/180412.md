# 180412

## 태린 수업
1. 변수 이름과, 클래스 이름이 같으면서
         같은 공간에 있는 경우 변수의 이름을 우선적으로 사용합니다.
         => 변수의 이름이 클래스 이름을 모호화 한다.

				2. 자바의 네이밍 컨벤션을 지키자

         => 클래스 이름 UUID -> Uuid
         => 클래스 이름은 약어라도 일반 이름처럼 취급


`x += i;` // 복합 할당 연산자
       short = 2byte => 2 ^ 15 -1 -= 32767

        복합할당 연산자 규칙
         연산 결과를 왼쪽 변수의 자료형으로 변환해준다.

 final 3가지
1. 상속 - class
2. 수정 - 필드 -> 한번 초기화만 가능
3. 오버라이딩 - 메서드

 파이널 키워드는
 필드에 적용하는 경우와, 메서드에 적용하는 경우에 다른 결과를 냅니다.


## 제네릭 메소드 (<T, R> R method(T t))
`public <T,...> R method(T t,...) {...}`


## 제한된 타입 파라미터 (<T extends 최상위타입>)
`public <T extends 상위타입> 리턴타입 메소드(매개변수, ...) {...}`
- 지정한 최상위 타입의 자식들도 파라미터로 받을 수 있게 됨

## 와일드카드 타입(<?>, <? extends …>, <? super …>)
- 제네릭타입<?> : Unbounded Wildcards ( 제한 없음 )
	- 타입 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올 수 있따.
- 제네릭타입 <? extends 상위타입> : Upper Bounded Wildcards (상위 클래스 제한) -> 명시한 타입과 그 자식들을 파라미터로 받을 수 있다.
	- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나 하위 타입만 올 수 있다.
- 제네릭타입 <? super 하위타입> : Lower Bounded Wildcards (하위 클래스 제한) -> 명시한 타입과 그 부모들을 파라미터로 받을 수 있다.
	- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 상위 타입이 올 수 있다.

**타입 파라미터 배열**
`(T[]) (new Object[capacity]);`

## 제네릭 타입의 상속과 구현
`public class ChildProduct<T, M> extends Product<T, M> {…}`

`public class ChildProduct<T, M, C> extends Product<T, M> {…}`

## 람다식
람다식의 형태는 매개 변수를 가진 코드 블록이지만, 런타임 시에는 익명 구현 객체를 생성한다.

람다식 -> 매개변수를 가진 코드 블록 -> 익명 구현 객체

**람다식의 형태**
`"(매개변수) -> { 실행 코드 }"`

매개 변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 있기 때문에 생략 가능
```java
(int a) -> { System.out.println(a); }
(a) -> { System.out.println(a); }

//하나의 매개변수만 있으면 괄호 생략 가능
a -> { System.out.println(a); }
```


`인터페이스 변수 = 람다식; ` -> 람다식은 인터페이스의 익명 구현 객체를 생성한다.

**함수적 인터페이스 (@FunctionalInterface)**
람다식은 하나의 메소드만 선언된 인터페이스만 사용가능
어노테이션을 붙이면 컴파일러가 체킹해줌 (실수 방지에 좋음)

**return 생략**
중괄호 안에 return문만 있고 , return문 뒤에 연산식이나 메소드 호출이 오는 경우엔 return 생략가능

**람다 this**
익명 객체 내부에서 this는 익명 객체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 객체의 참조가 아니라 람다식을 실행한 객체의 참조이다.


**람다식 밖 로컬 변수 사용할 때 final이여야 하는 이유**
인스턴스 변수는 heap영역에 저장이 되고, 지역 변수는 stack영역에 위치한다.

이런 상황에서 람다가 스레드에서 실행된 후, 변수를 할당한 스레드가 사라져 stack 메모리에서 해제되었으나, 람다를 실행하는 스레드는 살아 있어 해당 변수에 접근을 요청할 케이스가 생긴다.

이와 같은 이유로 ,
실제 변수에 접근을 허용하는 것이 아닌 해당 변수의 복사본을 만들어 그 곳에 접근을 허용하는데
당연히 처음에 복사한 값과 원본의 값이 달라지면 안되기 때문에, 람다에서 접근하는 지역 변수는 final로 선언되어야 한다.





#더더랩JAVA