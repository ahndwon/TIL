# 옵저버 패턴
한 객체의 상태가 바뀔 경우 다른 객체들에게 변경됐다고 알려주기 위해 사용하는 패턴이다.

상태를 가지고 있는 주체 객체와 상태의 변경을 알아야 하는 관찰 객체(Observer Object)가 존재하며 이들의 관계는 1:1이 될 수도 있고 1:N이 될 수도 있다.
서로의 정보를 넘기고 받는 과정에서 정보의 단위가 클수록, 객체들의 규모가 클수록, 각 객체들의 관계가 복잡할수록 점점 구현하기 어려워지고 복잡성이 매우 증가하기에 이러한 기능을 할 수 있도록 가이드라인을 제시해 주는 것이 바로 **옵저버 패턴**이다.

## 옵저버 패턴의 구조
옵저버 패턴은 스트레티지 패턴(Strategy Pattern)처럼 인터페이스를 이용하여 객체간의 느슨한 결합을 통해 구현한다. 즉 상속을 통한 구현이 아닌 구성(Composition)을 이용한다.
옵저버 패턴은 크게 두 가지의 역할로 나뉜다. 하나는 Publisher의 역할이고, 또 하나는 Observer의 역할이다. 이 역할들의 인터페이스를 정의한 후 이를 클래스들이 implement 한다.

**Publisher**
Observer들을 관리하는 메소드를 가지고 있는다.
기본적으로 3가지의 메소드를 가진다
1. add() - 구독을 원하는 Observer를 받아 등록한다
2. delete() - 명단에서 Observer을 제외시킨다.
3. notify() - 등록된 Observer들에게 정보를 알려준다.

**Observer**
Observer는 기본적으로 정보를 업데이트 해주는 Update 메소드를 가진다.

![](%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%8C%E1%85%A5%E1%84%87%E1%85%A5_%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB/7FB3BF94-905B-4607-8219-8E69C85851D0.png)
[옵저버 패턴](https://t1.daumcdn.net/cfile/tistory/99D577335994F7C924)

## 옵저버 패턴의 특징
**디커플링**
상태머신이 자신이 호출해 줘야 할 객체들을 모두 강하게 내부 변수로 가지고 있게 되면, 상태머신 자체를 다른 곳에서 재활용하기 힘들어진다.
![](%E1%84%8B%E1%85%A9%E1%86%B8%E1%84%8C%E1%85%A5%E1%84%87%E1%85%A5_%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB/5F3B4B6C-4538-424A-A416-0A3FF221676D.png)
[디커플링](https://t1.daumcdn.net/cfile/tistory/99914033599641BE23)

**제어역전**
옵저버 패턴은 전혀적인 제어 역전 구조로(Dependency Injection가 더 정확한 표현) 옵저버들이 상태머신을 계속 polling 하거나, 상태머신을 호출하는 것이 아니라, 상태머신에 자신의 레퍼런스를 넘겨서 (addObserver, addListener, subscribe) 상태머신에 의해 콜백되게 만든다.

## 옵저버 패턴의 문제
1. 예측 불가능한 순서
 Subject (상태머신) 자체내에서는 옵저버들을 보통 리스트를 순회하며 Notify를 해주게 되지만, 옵저버들의 추가, 삭제가 자유로이 이루어지고 있고, 개별 옵저버 입장에서는 자신이 호출되는 순서에 대해서 알 수가 없다. 따라서 상태변경에 따른 행위를 할 때, 자신의 순서 앞에서 어떤 다른 옵저버가 어떤 행위를 했는지를 미리 알 수가 없다. 제어권을 Subject로 제어역전 시켜 준 결과 이렇게 되버리는데, 이것을 해결 하기 위해서는 옵저버들 전체를 일종의 트랜잭션으로 감싸서 트랜잭션이 끝날 때 어떤 행위를 하게 끔 하는 수 밖에 없지만, 코드복잡도가 상당히 올라가게 된다.

2. 첫번째 이벤트 소실
Subject(상태머신)에 Dependency Injection를 해주는 시점이, Subject에서 첫번째 이벤트(상태변경)가 발생하는 시점 보다 늦게 될 수가 있다. 예를 들어 클라이언트가 접속되었다는 이벤트를 통지 받지 못한다면, 클라이언트와 상호통신하는 옵저버는 무용지물이 된다

3. 지저분한 상태
Subject(상태머신)는 위에서 보았다시피, 계속 변경되기 때문에 그로 인한 부수효과(side-effects)가 발생한다. 상태가 1~2개라면 괜찮으나, 상태가 점점 많아질수록 이벤트가 늘어나면서 코드가 몹시 복잡해진다. 그러므로 버그가 발생했을시 디버깅이 힘들어진다

4. 캡슐화 문제
옵저버 패턴은 캡슐화를 종종 깨버린다. 상태머신의 변경에 따라서 A옵저버가 mylist라는 변수를 초기화 시키고, B옵저버는 mylist라는 변수를 사용하게 되는 경우가 많이 있다.

5. 스레드 안전 문제
가장 곤혹스러운 문제이다. 일단 Subject(상태머신) 내에서도 락이나 경쟁관계를 해소해야하지만, 그것보다 더 큰 문제는 각각의 옵저버들과 그 옵저버들이 호출하는 함수체인 속에서 어떤 락을 잡고 있는지 알 수 없게 되는 경향이 있다. 즉 A 옵저버가 a락을 잡고 b락을 잡으려고 하지만, B 옵저버가 이미 b락을 잡기 있다면 문제가 발생한다. 

6. 콜백 누수
옵저버(리스너)를 등록 시킨 후, 쓸모가 없어 졌을 때 removeObserver, removeListener, dispos 등을 호출하는 것을 잊어 버렸다고 하자. 앞으로 상태가 변경 될 때마다 쓸떄없는 CPU 사이클만 날려버릴 것이다.
옵저버 패턴이 생산자와 소비자의 제어 관계를 자연스럽게 역전 시켜서 생산자가 소비자에게 의존하지 못하게 만드는 것이지만, 생산자의 실수를 소비자는 알 수가 없게 된다. 이상적이라면 이 관계를 다시 역전 시켜야 한다.

7. 의도치 않은 재귀
실제 현업에서 복잡한 솔루션을 짤 때, 이 문제도 쓰레드 문제와 같이 크게 다가오곤 한다. 예를 들어 커맨드 패턴에서 execute가 발생해서 -> 상태 머신(Subject)의 상태를 변경하면 -> 옵저버 A가 호출되고 -> 옵저버 B 가 호출 -> ... -> 옵저버 A는 어떤 다른 함수를 호출하고 그 함수는 -> 그함수가 동작 -> 끝나야 하지만 -> 마지막 함수는 다시 상태머신을 변경

종종 일어날 수 있는 실수이다.

8.  기타
Composability, SOC , Scalabilty, Abstraction, Resource management, Semantic distance 등이 있으며. 아래 레퍼런스 중 첫번째 마틴오더스키의 논문에 짧은 코멘트가 적혀져 있다.


### 문제 해결법
FRP(Functional Reactive Programming)을 통해 문제점 극복 가능

참고 사이트
[디자인패턴 - 옵저버 패턴(Observer Pattern)](http://flowarc.tistory.com/entry/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4Observer-Pattern)
[굿바이~ 옵저버 패턴 and FRP](http://hamait.tistory.com/885)
























#디자인패턴