# 2장 코틀린 기본기
중요 : when, 객체,구조 동등성, smart casting
## val, var
**var** 
	- 변경 가능한 변수를 선언하는 키워드
	- 변수에 값을 재지정하면 다른 값으로 변경될 수 있다.
	- 자바 변수 선언 방식과 같음
	- 나중에 초기화 가능

**val**
	- 읽기 전용 변수
	- 자바의 final 변수와 같음
	- 생성할 때 초기화 해야됨
	- 함수나 프로퍼티를 통해 인스턴스의 멤버 변수가 변경되는 것은 허용
	- 변수 자신이 자신의 값을 변경하거나 다른 값으로 재지정할 수 없다. 

## 타입 추론
코틀린 강타입 언어
그러나 항상 타입 명시적으로 선언할 필요 X
코틀린은 타입 추론을 함
보일러플레이트 코드는 줄이면서 타입 안전성 유지

타입 명시 -> ‘:’ 사용

## 기본 타입
자바와 코틀린의 차이 - 코틀린은 모든 것이 **객체**
코틀린은 원시 타입을 모두 객체로 승격 시킴 -> 래퍼 객체의 필요성 제거됨
박싱 : 원시 타입을 래퍼 타입으로 전환
언박싱 : 래퍼타입을 원시 타입으로 전환

## 숫자
코틀린은 자동으로 숫자 확장하지 않음 -> 명시적으로 변환해줘야 함

```java
// 정수 타입 -> long 타입
val int = 123
val long = int.toLong()
```

비트 연산자는 내장 연사자가 아닌 함수로 이루어짐
하지만 연산자처럼 실행
역은 단항 연산자이기 때문에 . 연산자로 호출 -> .inv()

## 불리언
단회로 특성 존재

## 문자 
Char
Char 타입은 자바처럼 숫자로 다뤄지지 않는다
유니코드 문자는 유니코드 숫자를 사용해 표현
\u1234 이런 방식으로 표현

## 문자열
자바와 마찬가지로 불변
문자열 리터럴은 이중 따옴표나 삼중 따옴표를 사용해서 생성
이중 따옴표 -> 끝에 이스케이프 문자 붙은 분자열 생성
삼중 따옴표 -> 원시 문자열 생성

## 배열
함수 arrayOf()를 사용해 배열을 생성

```java
//배열 생성
var array = arrayOf(1, 2, 3)
val perfectSquares = Array(10, { k -> k * k })
```
배열 클래스
ByteArray, CharArray, ShortArray, IntArray, LongArray, BooleanArray, FloatArray, DoubleArray

## 주석
// 라인 주석

/*
블록 주석
*/

## 패키지
Package com.packt.myproject

## 임포트
Import com.packt.myproject.Foo

## 와일드카드 임포트
같은 패키지에서 다수를 임포트해야 할 때 사용 ( *연산자)
Import com.packt.myproject.*

## 문자열 템플릿
+로 사용
문자열 보간법 - ${name.length}
 
## 범위
.. 연산자 사용

```java
val aToz = "a".."z"
val oneToNine = 1..9  
```
생성된 범위에 대해선 in 연산자를 통해 범위에 포함되는지 검사 가능
.downTo()	-	숫자를 하나씩 내리면서 범위 생성
rangeTo()	-	숫자를 하나씩 올리면서 범위 생성
step()		- 	범위에 있는 연속적인 항의 델타 값을 변경
reversed()	-	시작하는 값과 끝나는 값이 서로 바뀐 새로운 범위 반환, 단계값은 감소하는 값

## 루프
While 루프와 for 루프
향상된 for문 -> in 사용 

## 예외처리
자바와 예외 처리 비슷함
하지만 코틀린은 모든 예외는 확인되지 않은 예외
-> 확인된 예외는 반드시 메소드 시그니처 부분에 선언하거나 메소드 내부에서 다뤄야함

예외처리 -> try, catch, finals 사용

## 클래스 인스턴스화
new 키워드 더 이상 사용 X
생성자 함수가 클래스명을 사용함으로써 생성자 함수 호출을 일반 함수를 호출하는 것과 똑같이 처리
-> 그냥 new를 빼면 됨

## 참조 동등성과 구조 동등성
1. 두개의 각기 다른 참조가 메모리상에서 같은 인스턴스를 가리킴 -> 참조 동등성
2. 메모리상에서 두 객체는 각기 다른 인스턴스이지만 같은 값을 갖고 있는 경우 -> 구조 동등성

참조 동등성 (referential equality)
	- ===, !== 연산자 사용해서 비교

구조 동등성
	- ==, != 연산자로 비교 (자동으로 equals 함수를 사용하는 것으로 전환됨)
	- == 연산자는 널 값에 대해 안전함
		- 컴파일러가 널 체크를 해줌

## this 표현식
This - 현재 수신자
클래스의 멤버에서 this는 클래스 인스턴스를 참조한다
확장 함수에서 this는 확장 함수가 적용된 인스턴스를 참조한다.

## 가시성 제어자
가시성 제어자 - 몇몇 코드의 일부분을 내부 코드로 지정해 클래스나 패키지 바깥에서 접근하지 못하게 하는 것을 명시하기 위해 사용하는 키워드

Public , internal, protected, private
기본 값 - public

Private - 같은 파일에서만 접근 가능
Protected - 해당 클래스, 인터페이스, 서브클래스 맴버만 접근 가능
Internal - 모듈 개념,  같은 모듈에서 public 처럼 작동

## 표현식으로서의 흐름 제어
If else 나 try catch 문의 반환 값을 바로 변수에 대입 가능 -> 보일러플레이트 코드 줄여줌.

## 널 문법
코틀린은 널 값을 지정할 수 있는 변수는 ?와 함께 선언할 것을 요구한다.

is 연산자 - 자바의 instanceof 연산자와 같다.

**똑똑한 형변환**
코틀린 컴파일러는 타입을 확인했음을 기억해서 암시적으로 참조를 더욱 구체적인 타입으로 형변환한다.

**명시적 형변환**
 as 연산자를 사용
형변환 실패 시 ClassCastException 발생

## when 표현식
Switch 문 + 패턴 매칭 = when
when은 각 조건에 상수를 사용하지 않아도 됨.
1. **when(값)**
자바 switch 문과 비슷
else가 강제
is문 사용 가능
in
똑똑한 형변환 사용 가능
2. **인자가 없는 when**
If else 절 대체 -> 더 깔끔한 코드 생산 가능
많은 조건 비교하는 경우 해당

**함수 반환**
클로저로 값을 반환 가능

## 타입 체계
값을 지니지 않는 Nothing 타입 추가됨
Nothing
	- 인스턴스 X
	- Any는 모든 타입의 슈퍼클래스 <=> Nothing은 모든 타입의 서브클래스 
	- 컴파일러에 함수가 정상적으로 끝나지 않는다는 사실 알리는데 사용




 
#코틀린/코틀린 프로그래밍 책 정리#